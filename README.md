# CuckooMail
Connect Postfix mail server to cuckoo sandbox vm, making Postfix send all emails to a master email, where cuckoo sandbox vm will extract the emails from and analyze them. After that malicious files are automatically sent to a Flask server hosted on the Postfix mail server, which will run another program that deletes all malicious emails

First, we need to configure the postfix server to send a copy of all emails to a master email user, so in this example, I would be creating a user called Cuckoo. Use the "adduser Cuckoo" command to create the new Cuckoo user, and enter the password and other details. Next, open the /etc/postfix/main.cf and add the line "always_bcc=Cuckoo@yourdomain.com". This will make Postfix always Blind carbon copy the Cuckoo users email, therefore the Cuckoo user will receive a copy of all mail sent through the postfix server. Now if u login into your Cuckoo users email, and send an email to any emails in your domain, you should receive a copy of the email inside the Cuckoos user inbox.
![image](https://github.com/Cadenazar/CuckooMail/assets/88576308/ec3a8a13-c3d4-4750-bb5e-70a9c863fa83)

Next, we need to configure your Cuckoo sandbox VM to constantly download all email attachments that is sent through the Postfix server. So first download the email_downloader.py script, and store it in a directory your cuckoo user can access. I recommend using the "/opt" directory, you can create a directory called cuckoo inside the "/opt" directory, creating a directory path that looks like "/opt/cuckoo". Remember to modify all the fields that need to be changed such as the host,username and password variables. This code made use of a large part of https://openthreat.ro/cuckoo-sandbox-email-attachment-reader-scanner the code from here. However it fixes some bugs and vulnerabilities in the code such as remote code execution through file name, the attacker sends 2 files with the same name but different content causing the script to download only the first file received and lastly, the orginal code does not allow the running of files with spaces in their names. This was done by hashing the file content using SHA256 and using the file hash as the name of the downloaded file, therefore files with different file content but the same name will be named differently when downloaded.

We are going to make use of the cron service to run the email downloader script every 1 minute. So open the "/etc/crontab" file, and put in the line 
"*/1 * * * *     user    /usr/bin/python3.8 /opt/cuckoo/email_downloader.py >> email_downloader.log" this command will run the email_downloader script every minute and write all print outputs to the email_downloader.log file.You might need to change your python version, path, and user. You can now test the script by sending an email containing an attachment to any of your email addresses in your domain, after waiting for around a minute, Cuckoo sandbox should start running and analyzing the file. Remember to start your Cuckoo sandbox before testing the script. Also, remember to enable send file to virustotal to analyse inside the cuckoo sandbox config. You can do this by opening the ".Cuckoo/conf/processing.conf" file. Enable VirusTotal by setting the enabled field to yes and Scan field to yes. This will send all analyzed files to virustotal for further analysis.

![image](https://github.com/Cadenazar/CuckooMail/assets/88576308/21af695c-0283-41ec-8694-6377130d41e3)


Next we are going to make use of the cron service to retrieve the results of the analysis from Virustotal, I have not gotten the time to write the code for CuckooSandbox analysis results. However a general idea of how it can be done is, open the folder corresponding to the file u analyzed stored inside the ".cuckoo/storage/analyses" folder, for example in the example below, analysis number 1 is the only file I analyzed.

![image](https://github.com/Cadenazar/CuckooMail/assets/88576308/48232c8e-11ed-4620-8fe9-65ae0b199784)

Open the reports folder and inside there is a "report.json" file stored inside. By parsing the file and reading the contents, you can look for certain elements that are suspicious and relevant to malware files. For example, your Word documents and powerpoints make calls to an unknown IP address, or maybe certain virus signatures are found.

![image](https://github.com/Cadenazar/CuckooMail/assets/88576308/3ceef878-919c-49eb-b534-eaaf8a8c0bb7)


However, with the current virus_checker.py code, you are able to make use of virus total to delete malicious files. So firstly we need to download the file. Next, remember to modify all paths to fit the directory where the email_downloader.py stores all its jsons, the default should be your home directory. Remeber to change the VirusTotal api key to a valid one. I would be using the "/opt/virus_checker" directory to store the file. Next, open the "/etc/crontab" file and add the line 
"*/1 * * * *     test    /usr/bin/python3.8 /opt/virus_checker/virus_checker.py  >> virus_checker.log"
This would make the cron service run the virus_checker.py code every minute. You might need to change your python version, path, and user. Now you can test the code by sending an email to any emails in your domain, once Cuckoo sandbox and virus_total has finished analyzing the results, in a short moment you can look inside the virus_checker.log file, to see if the virus_total results were returned. The flask server you are sending to will give an error however that will be fixed later.

![image](https://github.com/Cadenazar/CuckooMail/assets/88576308/48c345dd-1cf4-4ff9-9a4a-82334922d409)

Next download the app.py script to your mail server. This is the script that is required to receive the list of downloaded files from the sandbox vm. I did not allow it to delete the malicious emails because it is bad practice to leave a root user open to the internet. Configure your flask server to run behind a proxy such as nginx. Following this guide https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-22-04 should help you accomplish this task. Next, enable https for your nginx proxy. I ran my flask server on port 5000, however, other ports should work as well. If you were like me and had issue enabling https as you had multiple different pages with the same domain name, a quick way you can enable https is by adding the lines.
ssl    on;
ssl_certificate    /etc/ssl/your_domain_name.pem; 
ssl_certificate_key    /etc/ssl/your_domain_name.key;
your flask nginx server file. I believe ssl on has been depreciated, and there is more secure way to do it. Now you can test the code by sending an email to any emails in your domain, once Cuckoo sandbox and virus_total has finished analyzing the results, in a short moment you can look inside the virus_checker.log file, to see if the virus_total results were returned. The flask server should download the malicious_files_{date}.json file and return a File submitted successfully response to the virus_checker.py script. You can also make use of Postman to test the API. Remember to update the API key used in virus_checker.py and app.py.

Lastly, we are going to make use of the Cron service to delete all malicious emails inside the email server. Download the email_deleter_base64_encode.py. I stored the file inside the "/opt/email_deleter" directory. This script will check the malicious_files_{date}.json received through the flask server and go through all user's email inboxes, if there are any emails containing the base64 content of a malicious file, the script will delete the email. Open the "/etc/crontab" file and add the line
"*/1 * * * *     root    python3 /opt/email_deleter/email_deleter_base64_encode.py"
This will make the cron service run the email_deleter_base64_encode.py script every 1 minute. If this is too slow, you can run the script by turning it into a service and using a while loop to run the code, while using the time library to add a delay between each loop. Remember to change the path of the directories used to the ones relevant to you. Such as a different home user directory. This code has a possible issue where it only uses the latest list of malicious files downloaded on the current date. For example, it will only delete files that are inside the malicious_files_2nd_jan.json and not files inside the malicious_files_1st_jan.json. To fix this issue, you can modify app.py to combine all received malicous_files_json together by appending the malicious file json contents together. Then make email_deleter_base64_encode.py make use of the combine malicous_files.json. This technically will still delete all received files , however, it is not very efficient and it will take more time for the files to be deleted as they have to be analyzed first.

Congratulations, you have implemented the CuckooMail code. Please take it easy on me because this is the first time I have published any code and Im still a student. So there are some inefficiencies and possible bugs that I have not ironed out.

